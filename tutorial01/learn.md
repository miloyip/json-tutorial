由于头文件也可以 #include 其他头文件，为避免重复声明，通常会利用宏加入 #include 防范（include guard）：

~~~ c
#ifndef LEPTJSON_H__
#define LEPTJSON_H__

/* ... */

#endif /* LEPTJSON_H__ */
~~~

宏的名字必须是唯一的，通常习惯以 _H__ 作为后缀。

如果项目有多个文件或目录结构，可以用 项目名称_目录_文件名称_H__ 这种命名方式。



C 语言的标准库含有 assert() 这个宏（需 #include ），提供断言功能。当程序以 release 配置编译时（定义了 NDEBUG 宏），assert() 不会做检测；而当在 debug 配置时（没定义 NDEBUG 宏），则会在运行时检测 assert(cond) 中的条件是否为真（非 0），断言失败会直接令程序崩溃。

初使用断言的同学，可能会把有副作用的代码放在 assert() 中：

~~~ c
assert(x++ == 0); /* 这是错误的! */
~~~

因为这样会导致 debug 和 release 版的行为不一样。
初学者可能会难于分辨何时使用断言，何时处理运行时错误（如返回错误值或在 C++ 中抛出异常）。简单的答案是，如果那个错误是由于程序员错误编码所造成的（例如传入不合法的参数），那么应用断言；如果那个错误是程序员无法避免，而是由运行时的环境所造成的，就要处理运行时错误（例如开启文件失败）。


